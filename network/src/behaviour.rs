use std::time::Duration;

use libp2p::{
    floodsub::{Floodsub, FloodsubEvent,Topic},
    identify::{Identify, IdentifyEvent},
    mdns::{Mdns, MdnsEvent},
    NetworkBehaviour,
    PeerId,
    ping::{Ping, PingConfig, PingEvent,PingFailure, PingSuccess},
    swarm::{NetworkBehaviourAction, NetworkBehaviourEventProcess},
};
use libp2p::{identity::Keypair};

use map_core::block::Block;

use crate::{config, error, NetworkConfig};
use std::num::NonZeroU32;

// We create a custom network behaviour that combines floodsub and mDNS.
// In the future, we want to improve libp2p to make this easier to do.
// Use the derive to generate delegating NetworkBehaviour impl and require the
// NetworkBehaviourEventProcess implementations below.
#[derive(NetworkBehaviour)]
#[behaviour(out_event = "BehaviourEvent", poll_method = "poll")]
pub struct Behaviour {
    pub floodsub: Floodsub,
    pub mdns: Mdns,
    pub ping: Ping,

    #[behaviour(ignore)]
    /// The events generated by this behaviour to be consumed in the swarm poll.
    events: Vec<BehaviourEvent>,
    // Struct fields which do not implement NetworkBehaviour need to be ignored
    #[behaviour(ignore)]
    #[allow(dead_code)]
    pub ignored_member: bool,
}

impl Behaviour {
    pub fn new(
        local_key: &Keypair,
    ) -> error::Result<Self> {
        let local_peer_id = local_key.public().into_peer_id();

        let ping_config = PingConfig::new()
            .with_timeout(Duration::from_secs(30))
            .with_interval(Duration::from_secs(20))
            .with_max_failures(NonZeroU32::new(2).expect("2 != 0"))
            .with_keep_alive(false);

        let mdns = Mdns::new().expect("dns initial error");

        Ok(Behaviour {
            floodsub: Floodsub::new(local_peer_id.clone()),
            mdns,
            ping: Ping::new(ping_config),
            events: Vec::new(),
            ignored_member: false,
        })
    }
}


impl NetworkBehaviourEventProcess<FloodsubEvent> for Behaviour {
    // Called when `floodsub` produces an event.
    fn inject_event(&mut self, message: FloodsubEvent) {
        if let FloodsubEvent::Message(message) = message {
            println!("Received: '{:?}' from {:?}", String::from_utf8_lossy(&message.data), message.source);
        }
    }
}

impl NetworkBehaviourEventProcess<MdnsEvent> for Behaviour {
    // Called when `mdns` produces an event.
    fn inject_event(&mut self, event: MdnsEvent) {
        match event {
            MdnsEvent::Discovered(list) =>
                for (peer, _) in list {
                    self.floodsub.add_node_to_partial_view(peer);
                }
            MdnsEvent::Expired(list) =>
                for (peer, _) in list {
                    if !self.mdns.has_node(&peer) {
                        self.floodsub.remove_node_from_partial_view(&peer);
                    }
                }
        }
    }
}

impl NetworkBehaviourEventProcess<PingEvent>
for Behaviour
{
    // Called when `ping` produces an event.
    fn inject_event(&mut self, event: PingEvent) {
        match event {
            PingEvent {
                peer,
                result: Result::Ok(PingSuccess::Ping { rtt }),
            } => {
                println!(
                    "ping: rtt to {} is {} ms",
                    peer.to_base58(),
                    rtt.as_millis()
                );
            }
            PingEvent {
                peer,
                result: Result::Ok(PingSuccess::Pong),
            } => {
                println!("ping: pong from {}", peer.to_base58());
            }
            PingEvent {
                peer,
                result: Result::Err(PingFailure::Timeout),
            } => {
                println!("ping: timeout to {}", peer.to_base58());
            }
            PingEvent {
                peer,
                result: Result::Err(PingFailure::Other { error }),
            } => {
                println!("ping: failure with {}: {}", peer.to_base58(), error);
            }
        }
    }
}

/// The types of events than can be obtained from polling the behaviour.
pub enum BehaviourEvent {
    AnnounceBlock(PeerId, Block),
    PeerDialed(PeerId),
    PeerDisconnected(PeerId),
    PubsubMessage {
        source: PeerId,
        topics: Vec<Topic>,
        message: Vec<u8>,
    },
}